fi_questions = [
        {"question": "Предмет информатики.", "answer": "Информатика: наука об осуществляемой преимущественно с помощью автоматических средств целесообразной обработке информации, рассматриваемой как представление знаний и сообщений в технических, экономических и социальных областях. "},
        {"question": "Информация и сообщения. Интерпретация сообщений.", "answer": "Информация и сообщения. Сведение — множественное число термина «Информация». Информация передается посредством сообщения, и наоборот, сообщение — то, что несет информацию. Сообщение является материальным носителем информации. Интерпретация:φ=N→I N−множество сообщений I−информация Информация i, которая передается сообщением n, устанавливается с помощью правила интерпретации, которое представляет собой отображение рассматриваемого множества сообщений B в множестве сведений. Сигналы: Вопрос: все что мы видим, слышим — аналоговый сигнал. К сигналам относят магнитные потоки, токи, колебания, звуки и тд. Аналоговые компьютеры работают на переменном токе. Пример: часы со стрелками, стрелочки еле заметно двигаются. Они демонстрируют непрерывное течение аналогового времени. Но в них пружины → они и дискретные тоже"},
        {"question": "Знаки и символы.", "answer": "Атомарным знаком или буквой называется элемент какого-либо упорядоченного конечного непустого множества графически (или каким-либо иным образом) отличимых друг от друга литер (предметов, сущностей, объектов, членов), называемого алфавитом. Составным знаком или словом называется конечная последовательность знаков(неважно, атомарных или составных). Множество слов тоже можно рассматривать как набор знаков (алфавит или словарь ). Символ - знак со смыслом"},
        {"question": "Кодирование.", "answer": "Кодом называется правило, описывающее отображение C: A → A' алфавита A на другой набор знаков A'. "
                "Так же стоит сказать, что если мы имели отображение φ, то теперь мы используем φ1 = C⁻¹ ∘ φ, где C⁻¹ — отображение, обратное C. "
                "Если известно C или C⁻¹, то говорят, что известен ключ кода C. "
                "Кодирование, при котором каждый образ является отдельным знаком, называется шифрованием. "
                "1. ASCII — таблица семибитного кода (1966), порядок знаков алфавита: служебные символы → пробел → 15 разделителей → десятичные цифры 0-9 → 7 разделителей → 26 заглавных латинских букв → 6 доп. символов → 26 малых латинских букв. "
                "2. КОИ-7 — таблица ASCII (1966), где вместо малых латинских букв помещены русские. "
                "3. EBCDIC (первая 8-битная кодировка, по-русски ДКОИ). "
                "4. КОИ-8, русские буквы размещены фонетически. То есть гашение старшего бита дает вместо АБВГД → ABVGD. "
                "// 8-битные удобнее 7-битных, однако мы все так же можем запомнить один алфавит. "
                "5. Unicode (первая 16-битная кодировка, 1988). Позволяет кодировать 65536 знаков вместо 256 8-битных кодов. "
                "Интересен факт, что 29000 позиций кодировки не заняты, а 6000 зарезервированы для использования программистами. "
                "Утверждение: Произвольный конечный набор знаков (алфавит) может быть закодирован знаками набора ω = (b0, b1). "
                "Доказательство: Знаки исходного набора могут быть закодированы знаками стандартного алфавита wm, где m — число знаков в исходном наборе. "
                "Пусть bi ∈ wm. Сопоставим ему код b0b1...b(i+1)∇"},
        {"question": "Системы счисления.", "answer": "Система счисления — это способ числовой интерпретации цифровых сообщений. "
                "Позиционная система счисления — это полиномиальный способ числовой интерпретации слов над цифровым алфавитом. "
                "Коэффициентами многочлена являются малые целые числа, означающие уже априори (вручную) проинтерпретированные цифры. "
                "Позиционная система задается одним натуральным числом p ∈ N — основанием системы счисления — которое однозначно определяет алфавит "
                "Ap = {0, 1, ..., p − 1} и функцию интерпретации. "
                "Wiki: Позиционная система счисления (позиционная, поместная нумерация) — система счисления, в которой значение каждого числового знака (цифры) в записи числа зависит от его позиции (разряда) относительно десятичного разделителя. "
                "Логический сдвиг представляет собой перемещение всех разрядов машинного слова влево или вправо на число разрядов, заданное вторым операндом. "
                "При этом освобождающиеся разряды заполняются нулями, а разряды, выходящие за пределы, теряются. "
                "При циклическом сдвиге разряды машинного слова считаются закольцованными, образуя двусторонний список, т. е. с одной стороны уходят, с другой приходят. "
                "При арифметическом сдвиге сдвиг влево — умножение, вправо — деление. "
                "В первом случае «знакомый» разряд двигается влево, а младшие теряются. "
                "При сдвиге вправо знаковый разряд остается неизменным, а старшие разряды выпадают. "
                "Слова Зайцева: Арифметический сдвиг — сдвиг влево (в урну выпадает 2 справа член), вправо (в 2 справа член добавляются 0)."},
        {"question": "Обработка сообщений.", "answer": "Обработка сообщений определяется правилом обработки ν, которое представляет "
                "собой отображение ν: N → N', где N — множество исходных сообщений, "
                "а N' — множество сообщений, получающихся в результате обработки. "
                "Примером обработки сообщений является кодирование (см. п. 1.5). "
                "Другие примеры обработки сообщений: перевод с одного языка на другой, "
                "чтение вслух, стенографирование, перепечатка текста на машинке, "
                "редактирование текста, решение системы уравнений и т. д. "
                "Обработка сообщений никогда не осуществляется «мгновенно», "
                "а всегда требует определенного времени, которым, как правило, нельзя пренебречь. "
                "Зависимость от времени приводит к понятию эффективности правила обработки сообщений, "
                "которая измеряется скоростью процесса обработки по сравнению со скоростями других процессов."},
        {"question": "Обработка информации.", "answer": "I — множество сведений. "
                "N — множество сообщений. "
                "Аналогично φ, φ': N' → I' — отображение множества сообщений N' в множество сведений I'. "
                "Если отображение φ обратимо (существует φ⁻¹), т.е. когда φ инъективно, "
                "то можно построить отображение σ, определяющее обработку информации "
                "σ: I → I' в виде σ = φ⁻¹ ∘ ν ∘ φ, так что i' = φ'(ν(φ⁻¹(i))), "
                "где i — начальная информация, i' — конечная. "
                "То есть, грубо говоря, имеем переход I → N → N' → I'. "
                "Если σ — отображение, то правило обработки сообщений ν называется сохраняющим информацию. "
                "Если ν сохраняет информацию, то диаграмма коммутативна, т.е. ν ∘ φ' = φ ∘ σ. "
                "В этом случае σ — правило обработки информации. "
                "Если σ — обратимое, то ν — перешифровка. "
                "Обратимую перешифровку ν называют перекодировкой."},
        {"question": "Автоматизация обработки информации.", "answer": "Заменим на прошлой диаграмме φ обратным отображением ψ = φ⁻¹, получим: "
                "Автоматизация обработки информации заключается в выполнении σ или φ⁻¹ ∘ ν ∘ φ' при помощи физических устройств. "
                "Для автоматизации обработки сообщений необходимо иметь физическое устройство, работа которого «моделировала» бы выполнение отображения ν. "
                "Для этого необходимо располагать тремя физическими представлениями: "
                "1. физическим представлением для множества исходных сообщений N — его мы будем обозначать буквой D и называть множеством исходных данных; "
                "2. физическим представлением для множества результирующих сообщений N' — его мы будем обозначать буквой D' и называть множеством результирующих данных (результатов); "
                "3. физическим представлением правила обработки ν, которое должно быть преобразованием, или последовательностью преобразований, оперирующих над D и дающих в результате элемент D', — его мы будем обозначать буквой P; преобразование P должно быть физически реализуемым, т.е. выполняться на некотором физическом устройстве. "
                "Необходимо автоматизировать выполнение трех отображений: "
                "1. отображения кодирования C, которое позволяет представить (абстрактное) сообщение из N с помощью элемента множества данных D, т.е. с помощью конкретного состояния некоторого физического устройства; "
                "2. отображения P, которое переводит элемент D в элемент D' — конкретное состояние еще одного физического устройства; "
                "3. отображения декодирования Q, которое позволяет проинтерпретировать результат — конкретное состояние физического устройства, представляющее элемент из D', переведя его в соответствующее сообщение из множества N'. "
                "Из диаграммы следует ν = C ∘ P ∘ Q, где C, P и Q должны выполняться автоматом."},
        {"question": "Конструктивное описание процесса обработки дискретных сообщений.", "answer": "Чтобы отображение P могло служить основой для автоматизации обработки сообщений, "
                "оно должно задавать некоторый способ построения сообщения d' = P(d), исходя из сообщения d ∈ D. "
                "Если D — конечное множество, то отображение P может быть задано таблицей, "
                "в которой перечисляются все сообщения d ∈ D и соответствующие им сообщения P(d). "
                "Примером такой таблицы может служить таблица умножения (или таблица сложения) однозначных чисел в позиционной системе счисления. "
                "Если же D бесконечно или по крайней мере так велико, что задание P с помощью таблицы оказывается непрактичным, "
                "то нужно представить P в виде последовательности элементарных шагов обработки (или тактов), "
                "каждый из которых состоит в выполнении одного или нескольких достаточно простых отображений, называемых операциями: "
                "P = P1 ∘ P2 ∘ ... ∘ Pk. "
                "Примеры операций: переписывание (копирование) буквы или слова, приписывание буквы к слову, приписывание слова к другому слову. "
                "КОРОТКО ГОВОРЯ: Если D — конечная, то надо построить таблицу, если бесконечная, то P надо представить в виде элементарных шагов обработки, "
                "каждый из которых состоит в выполнении элементных отображений, называемых операциями. "
                "Первый язык программирования — машинный язык."},
        {"question": "Свойства алгоритмов.", "answer": "Алгоритм — точно заданная последовательность правил, указывающая, "
                "каким образом можно за конечное число шагов получить выходное сообщение определенного вида, используя входное сообщение. "
                "1. Массовость — потенциальная бесконечность исходных сообщений, предназначенных для переработки алгоритмом. "
                "2. Детерминированность (однозначность, определенность) процесса применения алгоритма, заключающегося в последовательном выполнении дискретных действий. "
                "3. Элементарность каждого шага обработки, который должен быть легко выполним. "
                "4. Результативность алгоритма, точное описание того, что считается результатом применения алгоритма после выполнения всех требуемых шагов. "
                "5. Сложность алгоритма задается количеством простых операций, которые надо совершить для обработки сообщения. "
                "Это количество зависит от длины сообщения n и обычно задается некоторой функцией."},
        {"question": "Сложность алгоритмов.", "answer": "Класс сложности | Описание"
                "O(1) | Алгоритмы с постоянным временем выполнения, например доступ к элементу массива. "
                "При увеличении размера задачи вдвое время выполнения не меняется."
                "O(log n) | Алгоритмы с логарифмическим временем выполнения, например бинарный поиск. "
                "Время выполнения удваивается при увеличении размера задачи в n раз."
                "O(n) | Алгоритмы с линейным временем выполнения, например последовательный поиск или схема Горнера. "
                "При увеличении размера задачи вдвое время выполнения также удваивается."
                "O(n log n) | Алгоритмы с линеарифмическим временем выполнения, например быстрая сортировка. "
                "Время выполнения увеличивается немного больше, чем вдвое, при увеличении размера задачи в два раза.\n"
                "O(n^2) | Алгоритмы с квадратичным временем выполнения, например простые алгоритмы сортировки. "
                "Время выполнения увеличивается в 4 раза при увеличении размера задачи в 2 раза."
                "O(n^3) | Алгоритмы с кубическим временем выполнения, например умножение матриц. "
                "Время выполнения увеличивается в 8 раз при увеличении размера задачи в 2 раза."
                "O(2^n) | Алгоритмы с экспоненциальным временем выполнения, например задача о составлении расписания. "
                "Время выполнения увеличивается в 2^n раз при увеличении размера задачи в 2 раза."},
        {"question": "Семиотические модели интерпретации дискретных сообщений.", "answer": "Семиотика — наука о понимании. "
                "Строя математическое понятие модели, мы исходим из того, что внешний мир (среда) состоит из объектов (предметов), "
                "которые обладают определенными свойствами (атрибутами) и находятся в определенных отношениях друг с другом. "
                "Объектам, их атрибутам и отношениям ставятся в соответствие знаки (имена), из которых строятся сообщения "
                "(напомним, что дискретное сообщение — это последовательность знаков). "
                "Определение 1.11.1. Назовём k-местным отношением на множестве M совокупность r_k упорядоченных наборов из k элементов множества M "
                "вида ⟨x1, x2, ..., xk⟩. "
                "Определение 1.11.2. Моделью называется некоторое множество M с заданным на нем набором отношений ⟨r1(k1), r2(k2), ..., rn(kn)⟩. "
                "Иначе говоря, модель M — это упорядоченная пара объектов M = ⟨M, {r1(k1), r2(k2), ..., rn(kn)}⟩, "
                "где r1(k1), r2(k2), ..., rn(kn) — отношения на множестве M. "
                "Сигнатура (Ω) — это перечень знаков отношений. "
                "Теория — это упорядоченная пара T = (Ω, A), где A — множество аксиом, высказываний о свойствах сигнатуры Ω. "
                "Модель M называется моделью теории T, если M и T имеют одинаковую сигнатуру и если интерпретации φ каждого имени отношения теории, "
                "как одноименного отношения в модели, каждая аксиома теории становится истинным высказыванием."},
        {"question": "Необходимость формального определения алгоритма.", "answer": "Алгоритм — точно заданная последовательность правил, указывающая, "
                "каким образом можно за конечное число шагов получить выходное сообщение определенного вида, используя входное сообщение. "
                "Так как данное определение расплывчато, возникает необходимость формализации определения алгоритма: "
                "Формализация понятия алгоритма реализуется с помощью построения алгоритмических моделей. "
                "Можно выделить три основных типа универсальных алгоритмических моделей: "
                "рекурсивные функции (понятие алгоритма связывается с вычислениями и числовыми функциями), "
                "машины Тьюринга (алгоритм представляется как описание процесса работы некоторой машины, способной выполнять лишь небольшое число весьма простых операций), "
                "нормальные алгоритмы Маркова (алгоритмы описываются как преобразования слов в произвольных алфавитах). "
                "Все модели вышли из математики."},
        {"question": "Машины Тьюринга.", "answer": "Историческая справка: «В 1936 г. аспирант Алан Тьюринг при исследовании алгоритмических проблем разрешимости "
                "(одной из знаменитых проблем Гильберта) предложил для уточнения понятия алгоритма использовать абстрактную вычислительную машину "
                "с очень простым набором операций.»\n"
                "Тезис Тьюринга-Черча: Тезис говорит о том, что всякий интуитивный алгоритм может быть выражен средствами одной из алгоритмических моделей. "
                "Доказано, что одни модели сводятся к другим. Наиболее близкой к вычислительным машинам является машина Тьюринга.\n"
                "Неформальное определение: Машина Тьюринга состоит из ограниченной с одного конца бесконечной ленты, разделенной на ячейки, "
                "и комбинированной читающей и пишущей головки, которая может перемещаться вдоль ленты от ячейки к ячейке. "
                "В каждой ячейке ленты может быть записан один знак алфавита A, называемого рабочим алфавитом МТ, либо пробел (его мы будем обозначать знаком λ). "
                "При этом головка находится в одном из конечного множества Q = {q0, q1, ..., qs} дискретных состояний, среди которых выделено одно начальное состояние q0.\n"
                "Определено три вида элементарных действий: сдвиг головки на одну ячейку влево (если считать, что лента МТ ограничена слева, "
                "то для крайней левой ячейки сдвиг влево не определен), сдвиг головки на одну ячейку вправо, запись в рабочую ячейку какой-либо буквы рабочего алфавита A либо пробел "
                "(при этом буква, которая была записана в рабочей ячейке до выполнения записи, стирается).\n"
                "Команда МТ описывается упорядоченной четверкой символов (q, a, υ, q'), где:\n"
                "1. q ∈ Q — символ текущего состояния головки.\n"
                "2. a ∈ A ∪ {λ} — буква, записанная в текущей рабочей ячейке.\n"
                "3. υ ∈ {l, r} ∪ A ∪ {λ} — символ выполняемого действия.\n"
                "4. q' ∈ Q — символ состояния, в которое машина переводит головку.\n"
                "Математически строгое определение: Машиной Тьюринга называется упорядоченная четверка объектов T = (A, Q, P, q0), где:\n"
                "T — символ МТ, A — конечное множество букв (рабочий алфавит), Q — конечное множество символов (имен состояний), q0 — имя начального состояния, "
                "P = (q, a, υ, q'), где q, q' ∈ Q, a ∈ A ∪ {λ}, υ ∈ {l, r} ∪ A ∪ {λ}, определяющее три функции:\n"
                "функцию выхода Fl: Q × Ā → Ā (Ā = A ∪ {λ}), функцию переходов Ft: Q × Ā → Q, и функцию движения головки Fυ: A × Ā → {l, r, s}.\n"
                "Ситуацией (или состоянием ленты) называется упорядоченная пара объектов S = (z, k), где S — имя ситуации, z — сообщение, записанное на ленте, "
                "k — неотрицательное целое число, равное расстоянию (в ячейках) от края ленты до рабочей ячейки.\n"
                "Конфигурацией называется упорядоченная пара объектов C = (S, q), где S — текущая ситуация, q — текущее состояние головки."},
        {"question": "Нормальные алгоритмы Маркова.", "answer": "Историческая справка: Алгоритмы Маркова предложены в 1950 г. нашим соотечественником академиком А. А. Марковым.\n"
                "Неформальное определение: Нормальные алгоритмы Маркова по существу являются детерминистическими текстовыми заменами, "
                "которые для каждого входного слова однозначно задают вычисления и тем самым в случае их завершения порождают определенный результат.\n"
                "Марковская стратегия применения правил заключается в следующем:\n"
                "1. Если применимо несколько правил, то берется правило, которое встречается в описании алгоритма первым;\n"
                "2. Если правило применимо в нескольких местах обрабатываемого слова, то выбирается самое левое из этих мест.\n"
                "Строгое определение: Нормальный алгоритм Маркова (НАМ) задаётся конечной последовательностью правил (продукций, подстановок) p1, p2, ..., pn. "
                "Нормальный алгоритм Маркова начинает свою работу с начального входного слова w0, которое принадлежит (A ∪ A'). "
                "В процессе выполнения НАМ это слово подвергается постепенным изменениям. Такт работы алгоритма состоит в поиске правила, "
                "применимого к текущему обрабатываемому слову НАМ:\n"
                "• Поиск релевантного правила ведётся, начиная с первого правила НАМ;\n"
                "• Если ни одно правило не применимо, алгоритм завершается без терминирующего правила;\n"
                "• Первое подходящее правило применяется к самому левому вхождению слова из левой части правила;\n"
                "• После применения терминального правила НАМ завершается.\n"
                "Тезис Маркова: любой алгоритм в алфавите A может быть представлен нормальным алгоритмом Маркова над алфавитом A.\n"
                "Примерно так же, как и для МТ, можно доказать алгоритмическую неразрешимость проблемы остановки и самоприменимости."},
        {"question": "Диаграммы машин Тьюринга.", "answer": "Диаграммы Тьюринга представляют одни МТ через другие, более простые МТ иным, визуально-топологическим способом, "
                "причём, как будет показано далее, этот способ не менее строг и полон, нежели «обычные» МТ.\n"
                "При этом рассматриваемая МТ будет описана через элементарные МТ, т.е. такие, которые уже нельзя описать через более простые МТ, "
                "так как каждая из них выполняет всего одно элементарное действие и останавливается.\n"
                "Элементарные МТ над алфавитом Ap = (a1, a2, ..., ap) определяются следующими программами:\n"
                "• Элементарная МТ l (сдвиг головки на одну ячейку влево)\n"
                "• Элементарная МТ r (сдвиг головки на одну ячейку вправо)\n"
                "• Элементарные МТ λ, a1, ..., ap (запись соответствующего знака на ленту)."},
        {"question": "Моделирование машин Тьюринга.", "answer": (
                "Определение: Рассмотрим 2 МТ T = (A, Q, P, q0) и T' = (A', Q', P', q0'). "
                "Будем говорить, что машина T' моделирует машину T, и обозначать это T' ≃ T, если выполняются следующие условия:\n"
                "1. Указан способ кодирования знаков (букв) алфавита A знаками (буквами или словами) алфавита A': C: A → A'.\n"
                "2. Каждому состоянию q ∈ Q машины T поставлено в соответствие некоторое состояние q' ∈ Q' машины T', т.е. определено отображение Q → Q'.\n"
                "3. Если C0 — начальная конфигурация машины T, то ее образ C0' — начальная конфигурация машины T'.\n"
                "4. Если машина T из начальной конфигурации C0 после конечного числа тактов (переходов от одной конфигурации к другой) останавливается в конфигурации Ck, "
                "то машина T' из начальной конфигурации C0', являющейся образом C0, после конечного числа тактов также останавливается в конфигурации Ck', являющейся образом Ck.\n"
                "5. Если из начальной конфигурации C0 машина T пробегает (конечную или бесконечную) последовательность конфигураций C0, C1, ..., Ck, ..., "
                "то каждая последовательность конфигураций, пробегаемая машиной T' из начальной конфигурации C0', содержит в качестве подпоследовательности "
                "последовательность конфигураций C0', C1', ..., Ck', ..., где Ci' — образы конфигураций Ci машины T."
            )
        },
        {"question": "Эквивалентность программ и диаграмм.", "answer": (
                "Теорема 2.2.6: Каждой программе P, задающей МТ T = (A, Q, P, q0), можно эффективным образом сопоставить диаграмму D, "
                "образованную символами элементарных МТ, так, чтобы МТ, определяемая этой диаграммой, моделировала бы машину T.\n"
                "Доказательство:\n"
                "2.2.6.1 Построение диаграммы D: Каждой строке (q, a, v, q') ∈ P поставим в соответствие на диаграмме символы · v ·. "
                "Для v = s ничего ставить не надо, ведь пустые действия на диаграмме не отображаются. "
                "В этом случае окончанием работы машины, определяемой диаграммой, будет правая точка предыдущего элемента диаграммы. "
                "Поставим еще одну точку (•), соответствующую начальному состоянию диаграммы, и соединим ее стрелками → с левыми точками всех символов v, "
                "соответствующих строкам вида (q0, ai, v, q) ∈ P. Для каждой пары строк (q, ak, v, q') ∈ P и (q', aj, v', q'') ∈ P соединим стрелкой → правую точку символа v, "
                "соответствующего строке (q, ak, v, q') ∈ P, с левой точкой символа v', соответствующего строке (q', aj, v', q'') ∈ P и надпишем над стрелкой букву aj. "
                "В полученной таким образом диаграмме произведем необходимые упрощения, описанные в конце п. 2.2.3. Диаграмма D построена.\n"
                "2.2.6.2 Доказательство того, что машина TD, определяемая диаграммой D, моделирует машину T: Для этого достаточно показать, что выполнены условия 17 вопроса. "
                "Условие (1) выполняется потому, что алфавиты машин T и TD совпадают. Состояниям машины TD соответствуют точки на диаграмме D. "
                "По построению диаграммы каждому состоянию q машины T соответствует одна или две точки на диаграмме D. "
                "В последнем случае сопоставим состоянию q правую точку соответствующего символа на диаграмме. Таким образом, условие (2) выполнено. "
                "Условия (3)–(5) выполнены, так как диаграмма D определяет ту же последовательность элементарных действий, что и программа P, "
                "за исключением того, что у машины TD могут оказаться лишние «пустые» действия, соответствующие переходам от левых точек символов v к правым."
            )
        },
        {
            "question": "Эквивалентность диаграмм и программ.", "answer": (
                "Теорема 2.2.8: Каждой диаграмме Тьюринга D может быть эффективным образом сопоставлена программа P так, что МТ, описываемая этой программой, "
                "моделирует МТ, описываемую диаграммой D.\n"
                "Доказательство: Построение программы P. Заменим на диаграмме D все символы неэлементарных МТ их диаграммами, продолжая такую замену до тех пор, "
                "пока на диаграмме не останутся только обозначения элементарных МТ. В полученной диаграмме перенумеруем одинаковые символы элементарных МТ, "
                "снабдив их числовыми индексами. Перенумеруем также все точки, соответствующие выходным состояниям. "
                "Каждому символу элементарной МТ сопоставим программу этой машины из п. 2.2.3, пометив каждое состояние этой программы дополнительными индексами j и v, "
                "где v совпадает с названием соответствующей элементарной МТ, а j — номер, присвоенный этой элементарной МТ. Например, элементарной машине rj "
                "(j-е вхождение элементарной МТ r в диаграмме) будет сопоставлена программа:\n"
                "Точке с индексом j сопоставим программу вида:\n"
                "Соединим все программы, сопоставленные символам элементарных МТ и точкам, в одну и произведем в полученной программе следующие изменения:\n"
                "• Если на диаграмме символы элементарных МТ vj и vk соединены стрелкой a →, то строку (q1(v, j), a, s, q1(v, j)) заменим на (q1(v, j), a, a, q0(v, k)), "
                "т.е. останов машины vj заменим на перезапись буквы рабочей ячейки с последующим переходом прямо в начальное состояние машины vk, "
                "минуя конечное состояние машины vj;\n"
                "• Если на диаграмме между символами элементарных МТ vj и vk стоит точка, то проведем вышеуказанную замену для всех строк вида (qi, a, s, qi), "
                "тем самым предотвращается остановка машины на промежуточных этапах, изображаемых точками — «пустыми» машинами;\n"
                "• Введем новое начальное состояние q0 для генерируемой программы (оно соответствует крайней левой точке диаграммы) и добавим к программе пустые командные строки "
                "(q0, λ, λ, q0), (q0, ai, ai, q0) (i = 1, 2, ..., p), где ai — символы элементарных МТ, непосредственно следующих за крайней левой точкой диаграммы. "
                "Эти строки являются модифицированной программой элементарной машины «•», в которой остановка заменена перезаписью буквы в рабочей ячейке, "
                "т.е. реализуют холостой ход конструируемой программы;\n"
                "• Перенумеруем все состояния программы, за исключением нового q0, произвольным образом, введя сплошную нумерацию состояний, "
                "например, в лексикографическом возрастании индексов: qi(x, j) → qk.\n"
                "Постройте сами такое отображение индексов по схеме l, r, s, λ, ai × N2 → N.\n"
                "Проверка условий (1)–(5) определения 2.2.5: Условие (2) выполняется по построению программы P. Условия (3)–(5) выполняются потому, что обе МТ выполняют над сообщением, "
                "записанным на ленте (по построению программы P), одни и те же элементарные действия в одной и той же последовательности "
                "(дополнительные элементарные действия имеют вид (q, a, a, q'), т.е. не меняют ситуации на ленте)."
            )
        },
        {"question": "I теорема Шеннона. Доказательство*.", "answer": (
                "Теорема: Для любой машины Тьюринга T = (Ap, Q, P, q0) с множеством состояний Q = {q0, q1, ..., qs} можно эффективным способом построить машину Тьюринга "
                "T' = (Ar, {α, β}, P', q0'), моделирующую машину T и имеющую всего 2 состояния: α, β. Рабочий алфавит Ar содержит r = 3(p+1)(s+1)+p букв.\n"
                "Доказательство громоздкое и не очень понятное, строится на «предположим». Если хотите понять — читайте методичку, там написано более менее."
            )
        },
        {"question": "II теорема Шеннона. Доказательство*.", "answer": (
                "Теорема: Для любой машины Тьюринга T = (Ap, Q, P, q0) можно эффективным образом построить машину Тьюринга T'' = (A1, Q'', P'', q0''), "
                "моделирующую машину T и имеющую однобуквенный алфавит A1 = { | }.\n"
                "Доказательство: По факту каждой букве присваиваем количество | по ее номеру и доказываем работу этого через написание диаграмм элементарных действий."
            )
        },
        {"question": "Вычислимые функции.", "answer": (
                "Определение: Функцией из множества L в множество A't называется правило, которое каждому слову u ∈ L ставит в соответствие единственное слово w ∈ A't, "
                "называемое значением функции f на слову u.\n"
                "Определение: Функция f: (A's)n → A't называется вычислимой по Тьюрингу, если существует МТ с рабочим алфавитом Ap, содержащим алфавиты As и At, "
                "такая, что функция fT: (A's)n → A't, определяемая этой МТ, совпадает с f (fT = f).\n"
                "Определение: Предикат p: (A's)n → {И, Л} называется вычислимым по Тьюрингу, если существует МТ Tp с рабочим алфавитом At = As ∪ {И, Л}, "
                "которая вычисляет p и удовлетворяет следующим условиям:\n"
                "1. Если X = (u1, u2, ..., un) ∉ Def(p), то машина Tp никогда не останавливается.\n"
                "2. Если X = (u1, u2, ..., un) ∈ Def(p), и p(u1, u2, ..., un) = И, то машина Tp получает И.\n"
                "3. Если X = (u1, u2, ..., un) ∈ Def(p), и p(u1, u2, ..., un) = Л, то машина Tp получает Л."
            )
        },
        {"question": "Нормированные вычисления. Теорема о нормированной вычислимости. Доказательство*.", "answer": (
                "Определение: Функция называется нормированно вычислимой по Тьюрингу, если существует МТ Tf, которая вычисляет f и при этом удовлетворяет следующим требованиям:\n"
                "1. Если X = (u1, u2, ..., un) ∉ Def(f), то машина Tf после применения к X никогда не останавливается.\n"
                "2. Если X = (u1, u2, ..., un) ∈ Def(f), то Tf вычисляет значение функции.\n"
                "Теорема 1: Всякая ВТ-функция является НВТ-функцией, причем соответствующая МТ не использует никаких вспомогательных букв.\n"
                "Теорема 2: Для любой машины Тьюринга можно эффективным образом построить машину TN, которая имеет ленту, не ограниченную только с одного конца, "
                "и которая моделирует машину.")},
        {"question": "Теорема о композиции. Доказательство.",
            "answer": (
                "Теорема (О композиции): Пусть n-местная функция f: (A's)n → A't определяется равенством:\n"
                "f(u1, u2, ..., un) = h(g1(u1, u2, ..., un), g2(u1, u2, ..., un), ..., gm(u1, u2, ..., un)),\n"
                "где gi: (A's)n → A'r (i = 1, 2, ..., m) и h: (A'r)m → A't — ВТ-функции. Тогда f является ВТ-функцией, "
                "причем МТ, вычисляющая функцию f, может быть эффективно построена из МТ, вычисляющих gi."
            )
        },
        {
            "question": "Теорема о ветвлении. Доказательство.",
            "answer": (
                "Теорема (О ветвлении): Пусть n-местная функция определяется равенством, где gi: (A's)n → A't (i = 1, 2, ..., m) — ВТ-функции, "
                "а pi: (A's)n → {И, Л} — вычислимые предикаты. Тогда f является ВТ-функцией, причем МТ, вычисляющая функцию f, "
                "может быть эффективно построена из МТ, вычисляющих gi и предикаты pi (i = 1, 2, ..., m)."
            )
        },
        {
            "question": "Теорема о цикле. Доказательство.",
            "answer": (
                "Теорема: Пусть g: (A's)n → A's — ВТ-функция, вычисляемая машиной Tg, а p: (A's)n → {И, Л} — ВТ-предикат, вычислимый машиной Tp. "
                "Тогда функция f: (A's)n → A's, определяемая вычислительным процессом g = g0, g0 ∋ A's, "
                "f(u1, u2, ..., un) = g(u1, u2, ..., u(j-1), g, u(j+1), ..., un), пока p(u1, u2, ..., g, ..., un) = И, "
                "тоже является ВТ-функцией, причем МТ, вычисляющая функцию f, может быть эффективно построена из Tg, Tp."
            )
        },
        {
            "question": "Схемы машин Тьюринга. Нисходящая разработка.",
            "answer": (
                "Систематическое проектирование и разработка МТ и диаграмм МТ: Если мы хотим составить алгоритм, вычисляющий функцию f, "
                "ее надо представить в виде более простых функций. Расписываем машину Т на много маленьких Tj. Сводим большую программу на много маленьких.\n"
                "Далее в методичке идет пример Евклида по вычислению НОД.\n"
                "Всякую МТ, которая имеет одно начальное и одно конечное состояние, будем называть собственной. "
                "Выше было показано, что в состав диаграммы, описывающей собственную МТ, могут входить несобственные МТ. "
                "Если это не имеет места, т.е. если диаграмма, описывающая некую МТ, содержит только собственные МТ, "
                "то МТ, описываемая этой диаграммой, называется МТ с структурированным управлением, или структурной МТ. "
                "Легко видеть, что в процессе конструирования «сверху вниз» мы применяем только такие способы декомпозиции, "
                "при которых получаются именно структурные МТ. Диаграммы структурных машин мы будем называть схемами.\n"
                "Таким образом, схема МТ — это частный случай диаграммы Тьюринга.\n"
                "Определение: Понятие схемы машины Тьюринга определим следующим образом, отражающим нисходящий процесс конструирования:\n"
                "1. Символ • составляет схему.\n"
                "2. Если S1, S2, ..., Sn — схемы, то их последовательная композиция S1, S2, ..., Sn является схемой.\n"
                "3. Если C1, C2, ..., Cn — схемы МТ, вычисляющих предикаты P1, P2, ..., Pn соответственно, и S1, S2, ..., Sn — схемы, то и конструкции являются схемами.\n"
                "4. Символы элементарных машин Тьюринга составляют схемы.\n"
                "5. Никакие другие объекты схемами не являются.\n"
                "«А смерть этого злого чародея находилась на конце иглы. Та игла была в яйце, яйцо – в утке, утка находилась в зайце, "
                "а заяц – в сундуке, а сам сундук висит на высоком дубе, который рос на сказочном острове посреди моря – океана.»"
            )
        },
        {
            "question": "Теорема Бойма-Джакопини-Миллса. Доказательство.",
            "answer": (
                "Теорема Бойма-Якопини-Миллса: Для любой машины Тьюринга T можно эффективно построить машину Тьюринга S, которая является структурной, "
                "т.е. диаграмма является схемой, и которая моделирует машину T.\n"
                "Доказательство этой теоремы состоит в преобразовании каждой части диаграммы машины T в одну из трех структур, приведенных в определении схемы."
            )
        },
        {
            "question": "Универсальная машина Тьюринга. Построение*.",
            "answer": (
                "Определение: Машина Тьюринга, способная выполнить любой алгоритм, сымитировав работу соответствующей МТ, называется универсальной.\n"
                "В общем случае под универсальностью понимают способность некоторой системы моделировать работу любой другой системы, "
                "когда описание последней подается ей на вход в закодированном виде. Это определение не является вполне строгим, "
                "поскольку не указывается, какие способы кодирования являются допустимыми.\n"
                "Алгоритм работы УМТ: Напомним, что универсальной машиной Тьюринга (УМТ) для алфавита A называется такая машина U, "
                "на которой может быть промоделирована любая МТ над алфавитом A.\n"
                "На ленту УМТ записывается программа моделируемой МТ и исходное сообщение моделируемой МТ. "
                "УМТ по состоянию и текущему знаку МТ находит на своей ленте команду моделируемой МТ, выясняет, какое действие нужно выполнить, и выполняет его.\n"
                "Представление программы УМТ. Интерпретация моделируемой МТ:\n"
                "1. Поиск команды для выполнения:\n"
                "   (a) Запоминаем обозреваемую букву aj размножением состояний.\n"
                "   (b) Заменяем знак aj на его зеркальную пару bj.\n"
                "   (c) Ищем слово wi, содержащее запись команды.\n"
                "   (d) Ищем запись команды для знака aj.\n"
                "2. Изменение текущего состояния моделируемой МТ:\n"
                "   (a) Сдвигаемся на один знак вправо, пропуская vij.\n"
                "   (b) По описанию сдвига пропускаем соответствующее количество маркеров ci и ставим знак текущего состояния *.\n"
                "   (c) Возвращаемся к знаку описания vij действия.\n"
                "3. Выполнение действия моделируемой МТ:\n"
                "   (a) Ищем ячейку ленты, на которой находится головка моделируемой МТ.\n"
                "   (b) Выполняем считанное ранее действие, запись или сдвиг. Если при сдвиге головка попала на символ §, отделяющий программу моделируемой МТ "
                "от обрабатываемого сообщения, то моделируемая МТ зашла за левый край ленты.\n"
                "4. Переход на выполнение нового такта.\n"
                "Остановка моделируемой МТ: Если при сдвиге маркера текущего состояния (шаг 2.2) происходит переход на символ §, "
                "то следующим состоянием будет являться состояние остановки моделируемой МТ. В таком случае УМТ нужно выполнить действие моделируемой машины, а потом остановиться."
            )
        },
        {
            "question": "Линейная запись схем машин Тьюринга.",
            "answer": (
                "Рассмотрим, как можно линеаризовать каждое из этих сочетаний. Композиция состоит в последовательном выполнении.\n"
                "Язык описания схем машин Тьюринга: Правила линейной записи схем МТ составляют основу языка описания схем, названного ОСТ (Описание Схем Тьюринга)."
            )
        },
        {
            "question": "Критика модели вычислений Тьюринга.",
            "answer": (
                "Рассмотренные примеры программ на языке ОСТ показывают, что этот язык вряд ли можно считать удобным и эффективным средством описания алгоритмов. "
                "Описание программы, выполняющей несложный алгоритм сложения двух обыкновенных дробей, заняло страницу, а ведь оно было приведено далеко не полностью: "
                "почти все МТ, через которые описывается алгоритм, были объявлены «библиотечными» (описатель LIB), т.е. уже составленными при описании других алгоритмов "
                "и записанными на свободной части ленты.\n"
                "1. Недостаток: громоздкость описания. Описание программы, выполняющей несложный алгоритм сложения двух обыкновенных дробей, заняло страницу, "
                "а ведь оно было приведено далеко не полностью.\n"
                "2. Существенный недостаток языка ОСТ — необходимость многочисленных копирований. Если внимательно просмотреть описания МТ СЛОЖДР и НОД, "
                "можно заметить, что копирования составляют около половины всех действий, выполняемых при работе соответствующих МТ. "
                "Частые копирования не только резко увеличивают время выполнения программы, но и вызывают трудности при ее составлении; "
                "каждое слово присутствует на ленте в нескольких экземплярах, что усложняет проблему поиска нужных слов при составлении программы. "
                "В программе СЛОЖДР было употреблено восемь разных копирующих машин: K, K2, K3, K4, K5, K6, K10. Ясно, что количество таких машин потенциально бесконечно.\n"
                "Существенным недостатком языка ОСТ является также необходимость при составлении программы на этом языке выписывать ситуации на ленте, "
                "так как если этого не делать, то можно легко запутаться в расположении данных на ленте, что приведет к ошибкам при составлении алгоритма."
            )
        },
        {
            "question": "Алгоритмическая модель фон Неймана. Адреса и имена.",
            "answer": (
                "Универсальная МТ, D-лента которой содержит программы, реализующие арифметические действия, имеет качественно новый уровень по сравнению с универсальной МТ с пустой D-лентой: "
                "алгоритмы, связанные с выполнением арифметических действий над целыми числами (например, алгоритм Евклида), описываются на ней гораздо более простыми программами. "
                "Чтобы подчеркнуть это обстоятельство, назовем такую универсальную МТ арифметическим процессором."
            )
        },
        {
            "question": "Специализированные процессоры для обработки сообщений.",
            "answer": (
                "Предварительно разработав и записав на D-ленту набор внешних МТ, реализующих действия, используемые при составлении некоторого класса тьюринговых программ, "
                "мы получаем процессор для этого класса программ, позволяющий существенно упростить описания программ рассматриваемого класса и сократить процесс их разработки. "
                "Действия, реализуемые МТ, записанными на D-ленту, будем называть элементарными действиями процессора или операциями. "
                "Все внешние МТ, реализующие операции, имеют одинаковый рабочий алфавит, называемый рабочим алфавитом процессора. "
                "Этот алфавит является рабочим алфавитом всех программ, выполняемых на процессоре.\n"
                "Для построения процессора необходимо:\n"
                "• Выбрать и зафиксировать рабочий алфавит процессора; обычно в качестве рабочего алфавита будем брать множество Ap = {0, 1, 2, ..., p-1} первых p неотрицательных чисел (начиная с 0); "
                "слова над алфавитом Ap допускают естественную интерпретацию как неотрицательные целые числа в позиционной системе счисления с основанием p.\n"
                "• Зафиксировать конечное или бесконечное множество допустимых слов над алфавитом Ap; если множество допустимых слов конечно и включает лишь слова фиксированной длины k "
                "(либо слова, имеющие длину не больше, чем k), то удобно добавить к множеству допустимых слов еще одно слово, называемое «переполнением» — ⊤, "
                "которое означает, что в результате выполнения операции получилось слово, имеющее длину, большую, чем k; множество допустимых слов может также содержать слово ⊥, "
                "обозначающее неопределенное значение операнда, см. п. 3.1.\n"
                "• Составить и записать на D-ленту программы МТ, выполняющие операции процессора (включая операции РИМ и АДР).\n"
                "• Сообщить обозначения операций универсальной МТ, точнее — управляющей программе этой универсальной МТ, на основе которой строится процессор.\n"
                "В число операций процессора могут входить отношения, т.е. такие операции, которые по одному или нескольким допустимым словам (аргументам отношения) "
                "вычисляют логическое значение И (истина) или Л (ложь); количество аргументов каждого отношения постоянно и называется его местностью. "
                "Строго говоря, отношения связывают числовые операнды, имеют истинностные значения и не являются операциями, поскольку размыкают множество допустимых операндов.\n"
                "Согласование процессоров:\n"
                "Определение 2.9.1: Два процессора называются согласованными, если определены функции (операции) перевода всех допустимых слов одного процессора в допустимые слова другого процессора и обратно."
            )
        },
        {
            "question": "Построение универсального процессора фон Неймана.",
            "answer": (
                "Если управляющую программу и все D-ленты многоленточного процессора заменить новым управляющим устройством, которое может выполнять все операции рассматриваемых D-лент, "
                "получится новый тип процессора, называемый процессором фон Неймана.\n"
                "Таким образом, процессор фон Неймана состоит из полубесконечной S-ленты, на которую записывается программа и ее данные, одной или нескольких R-лент, "
                "на которые вызываются операнды соответствующих процессоров перед выполнением операций, и управляющего устройства, просматривающего и интерпретирующего программу, "
                "записанную на S-ленте.\n"
                "Вычислимость по фон Нейману — всё, что компьютер может вычислить на обозримое время."
            )
        },
        {
            "question": "Машина фон Неймана: принципы реализации.",
            "answer": (
                "Машиной фон Неймана называется аппаратная реализация процессора фон Неймана. Машина фон Неймана состоит из управляющего устройства, "
                "устройства памяти (аппаратная реализация S-ленты) и одного или нескольких регистров (аппаратная реализация R-лент).\n"
                "Устройство памяти машины фон Неймана имеет два существенных различия с S-лентой. Во-первых, в отличие от S-ленты, устройство памяти содержит лишь конечное число ячеек ограниченного размера, "
                "так что не любая вычислимая по Тьюрингу (Маркову, Посту, Черчу, Флойду, Тромпу и т.д.) функция вычислима на машине фон Неймана. "
                "Во-вторых, данные, записанные в ячейки устройства памяти, недоступны для непосредственного восприятия человеком. "
                "Следовательно, в состав машины фон Неймана должны входить устройства записи сообщений в память (устройство ввода) и вывода данных из памяти на носитель, "
                "доступный для восприятия органами чувств человека (устройство вывода). Все устройства ввода так или иначе преобразуют сообщения разного вида во внутримашинные данные "
                "(двоичные слова: именно фон Нейман предложил использовать двоичную систему счисления при аппаратной реализации ЭВМ!). "
                "Например, микрофон преобразует поперечные звуковые колебания воздуха в релевантные аналоговые электрические сигналы. "
                "Для их обработки цифровыми устройствами, эти сигналы должны быть преобразованы в дискретную форму звуковой платой. "
                "Современные устройства вывода способны воздействовать не только на зрение, но и на слух, обоняние, осязание, вкус. "
                "Кроме того, используя инерцию органов зрения, возможно создание движущихся изображений. "
                "По этой же причине даже если бы мы смогли чувствовать данные во внутримашинном представлении, мы не поспевали бы за их слишком быстрым изменением. "
                "Следовательно, язык описания программ для машины фон Неймана должен содержать средства управления устройствами ввода и вывода, "
                "преобразующими сообщения в данные и наоборот."
            )
        },
        {
            "question": "Структура программ для машины фон Неймана.",
            "answer": (
                "Машина фон Неймана состоит из управляющего устройства, включающего управляющую программу и микропрограммы операций машины, памяти и регистров. "
                "Для обеспечения работы машины фон Неймана необходимо поместить в ее память следующие объекты: программу, таблицу имен и все данные, которые должна обработать программа.\n"
                "Каждый объект размещается в одной или нескольких ячейках памяти и, следовательно, связывается с определенными адресами памяти. "
                "В соответствии с одним из принципов фон Неймана программа и данные помещаются в одном и том же устройстве памяти. "
                "И только на регистрах процессора слова с командами программы и данными существенно различаются. "
                "Этот принцип позволил упростить конструкцию первых ЭВМ и был назван принстонской архитектурой по названию университета, где работал фон Нейман. "
                "Кроме простоты реализации принстонская архитектура позволила немедленно выполнять только что сгенерированную в памяти программу, "
                "которая еще мгновение назад была выходными данными другой программы, облегчив тем самым построение операционных систем, систем программирования и отладчиков. "
                "Недостатком принстонской архитектуры является ее небезопасность, поскольку этими же возможностями могут воспользоваться вирусы, трояны и прочие программные паразиты.\n"
                "Таблица имен, программа и данные могут быть записаны в виде, непосредственно переносимом в память машины. "
                "При этом все заботы об установлении соответствия между именами и адресами, размещении данных в памяти, определении начальных значений некоторых данных полностью ложатся на программиста.\n"
                "Таким образом, программа для машины фон Неймана представляет собой текст, обязательно включающий в себя инструкции описания объектов (данных, которые обрабатывает программа), "
                "инструкции ввода данных (они могут отсутствовать, если необходимые для вычислений начальные значения объекты получают при размещении их в памяти машины), "
                "инструкции обработки данных и инструкции вывода значений объектов-результатов."
            )
        },
        {
            "question": "Нотация программ Э. Дейкстры. Обобщенные инструкция присваивания и композиции.",
            "answer": (
                "Обобщенная инструкция присваивания: Согласно одному из принципов фон Неймана вычислительная машина должна осуществлять покомандную обработку данных. "
                "Операнды каждой команды вызываются на регистры из памяти, после чего эта команда выполняет необходимое действие над ними, оставляя результат также на регистрах.\n"
                "X обозначает имя объекта (простой, индексированной или квалифицированной переменной, либо, иногда, массива), A — выражение, задающее последовательность действий над операндами.\n"
                "Имеет следующий императивный смысл: сделать адрес объекта с именем X адресом значения объекта A.\n"
                "Например, перемножение чисел A * b + D.\n"
                "Определение: Обобщением инструкции присваивания является инструкция, задающая одновременную замену значений нескольких объектов. "
                "Левая часть такой инструкции представляет собой список именованных объектов. "
                "Правая часть инструкции должна содержать столько же выражений, сколько имен объектов в списке левой части инструкции, или одно выражение. "
                "В первом случае инструкция одновременного присваивания имеет вид.\n"
                "И в дейкстровской нотации, и в Python допустима циклическая перестановка значений объектов.\n"
                "Обобщенная инструкция композиции: Общепринятый и широко используемый способ организации вычислений громоздких выражений — функциональная композиция, "
                "состоящая в том, что значения одной или нескольких функций используются в качестве аргументов для других функций."
            )
        },
        {
            "question": "Обобщенная инструкция ветвления.",
            "answer": (
                "Правила выполнения инструкции ветвления следующие:\n"
                "◦ Одновременно и независимо вычисляются все предохранители.\n"
                "◦ Среди вычисленных предохранителей инструкции ветвления должен быть хотя бы один, принимающий значение И. "
                "Если среди предохранителей инструкции ветвления нет ни одного, принимающего значение И, то происходит ОТКАЗ — выполнение программы прекращается (аварийно!). "
                "Таким образом, отсутствие среди предохранителей инструкции IF–FI предохранителя, принимающего в момент выполнения инструкции значение И, "
                "воспринимается как грубая ошибка периода выполнения, препятствующая дальнейшему хоть сколько-нибудь осмысленному выполнению программы. "
                "Дело в том, что при планировании ветвления программист должен позаботиться о «полноте» системы предикатов в охраняемых инструкциях, "
                "и предусмотреть дополнительную ветвь, отрицающую все предикаты.\n"
                "◦ Допускается, чтобы среди предохранителей инструкции ветвления было более одного предохранителя, принимающего значение И при выполнении инструкции IF–FI."
            )
        },
        {
            "question": "Обобщенная инструкция цикла.",
            "answer": (
                "◦ Если среди предохранителей инструкции DO–OD один и только один принимает значение И, то соответствующая охраняемая инструкция выполняется, "
                "и после этого вновь осуществляется одновременная и независимая проверка всех предохранителей инструкций цикла. "
                "Следует обратить внимание на то, что охраняемой инструкцией может быть композиция или ветвление.\n"
                "◦ Количество предохранителей, принимающих значение И, также может быть более одного. "
                "В этом случае не предполагается, что охраняемые инструкции упорядочены и выбор инструкции для выполнения очередного повторения цикла "
                "осуществляется вне связи с порядком их написания в инструкции DO–OD, т.е. недетерминированным образом.\n"
                "◦ Если среди предохранителей инструкции DO–OD нет ни одного, принимающего значение И, то, в отличие от ветвления, выполнение инструкции заканчивается "
                "естественным образом в связи с отсутствием инструкции, открытой для продолжения работы цикла.\n"
                "◦ Выполнение каждой охраняемой инструкции должно приводить к изменению аргументов предохранителей. "
                "В противном случае выполнение инструкции DO–OD может никогда не закончиться."
            )
        },
        {
            "question": "Понятие типа данных.",
            "answer": (
                "Тип данных — это множество изображений (слов над некоторым алфавитом), для которых определено правило их интерпретации, "
                "позволяющее каждому изображению сопоставить его значение, и множество атрибутов, которые позволяют одному или нескольким элементам типа данных "
                "сопоставить либо изображения данных того же типа, либо изображения данных другого типа.\n"
                "φ: W → X, где W — множество изображений, а X — множество значений.\n"
                "Множество изображений, составляющих тип данных, может быть задано несколькими способами:\n"
                "1. Непосредственным перечислением изображений.\n"
                "2. Заданием характеристической функции.\n"
                "3. С помощью системы аксиом, определяющих изображения через их свойства.\n"
                "Тип, который задается аксиоматически и имеет физическую реализацию, называется базовым типом.\n"
                "Основными базовыми типами языков программирования являются логический (BOOLEAN), целый (INTEGER), вещественный (REAL) и литерный (CHAR).\n"
                "Все упомянутые выше типы данных: базовые (BOOLEAN, INTEGER, REAL, CHAR), тип перечисления и отрезок типа — являются неструктурными (скалярными) типами данных.\n"
                "Пример: Для представления студенческой группы в ЭВМ используется структурный тип данных, называемый массивом."
            )},
        {"question": "Тип логический.",
            "answer": (
                "Значениями логического типа являются Истина, Ложь и Неопределенность (изображаемые словами И, T, true, либо Л, F, false и ⊥).\n"
                "Над значениями логического типа определены:\n"
                "◦ Одноместная операция ¬ (отрицание, NEG или «!»);\n"
                "◦ Двуместные операции & (конъюнкция, AND) и ∨ (дизъюнкция, OR или |);\n"
                "◦ Отношения ≡ (эквиваленция, тождественность) и !≡ (нетождественность, исключающее ИЛИ, ^, XOR).\n"
                "Операции логического типа обладают следующими свойствами:\n"
                "1. Если хотя бы один операнд имеет значение ⊥, то и результат имеет значение ⊥.\n"
                "2. Если оба операнда дизъюнкции (конъюнкции) истинны (ложны), то истинен или ложен результат, то есть X & X = X, X ∨ X = X.\n"
                "3. Если X истинно, а Y имеет произвольное логическое значение, отличное от ⊥, то X ∨ Y также является истинным: X ∨ Y = X.\n"
                "4. Если X ложно, а Y имеет произвольное логическое значение, отличное от ⊥, то X & Y также является ложным: X & Y = X.\n"
                "5. Дизъюнкция и конъюнкция коммутативны: X ∨ Y = Y ∨ X, X & Y = Y & X.\n"
                "6. X ∨ ¬X всегда истинно, если только X ≠ ⊥.\n"
                "7. X & ¬X всегда ложно, если только X ≠ ⊥.\n"
                "8. ¬¬X = X (¬¬X можно заменить на X)."
            )
        },
        {
            "question": "Тип литерный.",
            "answer": (
                "Константы литерного типа — самоопределённые термы — заключаются в апострофы или кавычки: ’3’, ’а’. "
                "Множество значений определяется конкретной кодировкой: ASCII, КОИ-8 и т.д. "
                "Эта кодировка задаёт порядковый номер литеры, определяемой функцией преобразования типа ord, связывающей литерный тип с поддиапазоном целого."
            )
        },
        {
            "question": "Тип целый.",
            "answer": (
                "Из курса алгебры известно, что множество целых чисел состоит из бесконечного числа элементов вида 0, ±1, ±2, ..., "
                "удовлетворяющего системе аксиом и образующего алгебраическое кольцо относительно сложения и умножения.\n"
                "ℤ = {z ∈ ℤ | MIN ⩽ z ⩽ MAX} ∪ {⊥; ⊤}\n"
                "Над значениями целого типа определены обычные целочисленные арифметические операции, а именно: сложение (+), вычитание (-), умножение (*), целочисленное деление.\n"
                "1. Коммутативность сложения и умножения: ∀ X, Y ∈ ℤ, X + Y = Y + X, X * Y = Y * X.\n"
                "2. Если X ≥ Y ≥ 0 или X ≤ Y ≤ 0, то (X − Y) + Y = X.\n"
                "3. Монотонность операций: из 0 ≤ X ≤ A и 0 ≤ Y ≤ B следует X + Y ≤ A + B; X − B ≤ A − Y; X * Y ≤ A * B; X + B ≤ A + Y.\n"
                "Всё это верно только если A + B ≤ MAX и A * B ≤ MAX соответственно.\n"
                "4. Если хотя бы один из операндов операции целого типа имеет значение ⊤, то результат операции тоже имеет значение ⊤ или ⊥ соответственно. "
                "Если один операнд двуместной операции имеет значение ⊥, а другой ⊤, то результат операции имеет значение ⊥.\n"
                "5. Если один из операндов отношения целого типа имеет значение ⊥ или ⊤, то результат имеет значение ⊥. "
                "Строго говоря, это неопределенное значение принадлежит логическому типу.\n"
                "Нет коммутативности разности, т.к. нет пары для самого малого отрицательного числа.\n"
                "16-разрядный целочисленный процессор с дополнительным кодированием целых имеет следующий диапазон: [−32 768..32 767].\n"
                "Диапазон 32-разрядного процессора существенно шире: [−2 147 483 648..2 147 483 647].\n"
                "В 64-разрядном процессоре: [−9 223 372 036 854 775 808..9 223 372 036 854 775 807].\n"
                "Ассоциативность и дистрибутивность не работают в целом типе, т.к. имеются ⊥ и ⊤.\n"
                "MAX, MIN = 2^(k−1) и 2^(k−1)−1.\n"
                "Целый тип вычислим по Тьюрингу (нужно сделать ДТ операций +, -, *, /)."
            )
        },
        {
            "question": "Тип вещественный.",
            "answer": (
                "Очень большая тема, лучше конкретно ее прочтите в методичке.\n"
                "r = p/q, r ∈ ℚ, p ∈ ℤ, q ∈ ℕ.\n"
                "При этом основания системы счисления для дроби и для экспоненты, вообще говоря, могут быть разными. "
                "Цузе предложил число −1.23 перевести в нормализованную форму −0.123 * 10^1 и представить в ЭВМ тремя частями одного машинного слова.\n"
                "Множество изображений вещественного типа — это множество слов конечной длины над алфавитом {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} ∪ {+, −, ., E}, "
                "причем длина слова, изображающего вещественное число, в языке программирования не фиксирована и определяется с помощью соответствующих базовых атрибутов, "
                "которые имеют определенное значение для каждой реализации.\n"
                "Итак, вещественное число с плавающей точкой фактически изображается с помощью двух целых чисел p и m, каждое из которых содержит конечное (фиксированное для каждой реализации) число цифр, "
                "так что вещественное число X = m * B^p, причем minexp ≤ p ≤ maxexp; minmant ≤ m ≤ maxmant; m называется мантиссой; p — порядком, "
                "а B, minexp, maxexp, minmant и maxmant являются константами, характеризующими представление; число B называется основанием представления с плавающей точкой.\n"
                "Итак, ИНТвещ(m, p) = m * B^p.\n"
                "К базовому множеству атрибутов вещественного типа относятся:\n"
                "◦ Изображения выделенных значений MINREAL и MAXREAL, определяющих диапазон представления, а также ⊥ и ⊤; значение ⊤ представляет числа из диапазона переполнения.\n"
                "◦ Операции: сложение, вычитание, умножение и деление с плавающей точкой.\n"
                "◦ Отношения порядка.\n"
                "◦ Функции: ABS, SQRT, SIN, COS, EXP, LN, ARCTAN.\n"
                "Заметим, что уже в стандарте IEEE 754 неопределённость (NaN, Not A Number) и переполнение (+/−∞) имеют аппаратную поддержку. "
                "Там же специфицируются значащий нуль и ненормализованные значения.\n"
                "Машинное эпсилон характеризует точность плавающей арифметики. Вычисляется в районе единицы, потому что нормализация числа приводит мантиссу к правильной дроби без ведущих нулей после запятой.\n"
                "При использовании чисел типа REAL получаем приближенные результаты, что связано с неустранимой погрешностью.\n"
                "А при дополнительных округлениях сталкиваемся с погрешностью округления (возникает и при переходах из разных систем счисления)."
            )
        },
        {
            "question": "Согласование типов.",
            "answer": (
                "Подобно многотиповой машине фон Неймана, язык программирования фон Неймановского типа допускает согласованное использование различных типов данных в вычислениях. "
                "Выражения со смешанными типами явно (с помощью функций согласования типов) или неявно (функции преобразования осуществляются компилятором или языковой средой по умолчанию) "
                "приобретают вполне определённый однозначный смысл."
            )
        },
        {
            "question": "Небазовые типы данных (диапазон, перечисление, множество).",
            "answer": (
                "Отрезок (диапазон): Здесь в качестве множества значений берётся отрезок вещественного типа, операции и отношения также заимствуются из вещественного типа.\n"
                "Пример: type diap = (0.0..2.0; real; real);\n"
                "Перечисление: Пример: StreetLight = ((Red, Yellow, Green); := ; integer);"
            )
        },
        {
            "question": "Понятие о структурном типе данных.",
            "answer": (
                "Рассмотрим типы данных со структурными значениями. Структурные значения — это упорядоченные систематически организованные совокупности других (быть может, то же структурных) значений, "
                "рассматриваемое как единое целое. Компоненты структурных значений также называются его полями или элементами.\n"
                "Типичным примером структурного типа является комплексный тип, состоящий из двух вещественных полей: вещественной и мнимой частей.\n"
                "Переменные и константы структурного типа называются структурными."
            )
        },
        {
            "question": "Тип массив.",
            "answer": (
                "Тип массив — это регулярный структурный тип с индексированным методом доступа.\n"
                "Пример:\n"
                "const int MAX = 20;\n"
                "int data[MAX][MAX];\n"
                "Ввиду скалярности машины фон Неймана обработка массивов осуществляется покомпонентно, как правило, с помощью циклов с параметром (for), "
                "с подстановкой параметра цикла в индексное выражение. Кроме того, сложные индексные выражения позволяют осуществлять различные обходы или переборы компонент, "
                "параметр цикла как своеобразное время цикла в индексном выражении становится указателем пространства, т.е. цикл по времени становится циклом по пространству."
            )
        },
        {
            "question": "Тип запись.",
            "answer": (
                "Тип записи — это комбинированный структурный тип с квалифицированным методом доступа. "
                "Комбинированность означает, что поля записи, вообще говоря, имеют различные типы. "
                "Квалифицированный доступ, в отличие от индексированного, негибок и невычислим, так как требует явного указания статически определённых до компиляции имён полей.\n"
                "Пример:\n"
                "#include <stdio.h>\n"
                "struct Person {\n"
                "    char name[10];\n"
                "    char lastname[19];\n"
                "    int age;\n"
                "};\n"
                "int main() {\n"
                "    struct Person mer = {\"Ivan\", \"Ivanovich\", 18};\n"
                "    printf(\"%s\", mer.name);\n"
                "}"
            )
        },
        {
            "question": "Понятие о файлах.",
            "answer": (
                "Структура файла является обобщением понятия последовательности. Поэтому файлы прямого доступа следует считать «массивами на диске». "
                "Компоненты файла должны быть одного типа, и они доступны только путём последовательного прочтения. "
                "Поскольку файлы ввиду их потенциально большого размера размещаются на устройствах внешней памяти, в каждый момент времени доступна лишь текущая компонента файла, "
                "а другие компоненты могут быть получены лишь последовательным прочтением компонент файла вперёд, или, после перемотки, с начала. Движения «назад» нет ввиду инерционности электромеханических устройств.\n"
                "Файлы принято подразделять на внешние и внутренние, текстовые и нетекстовые, входные и выходные.\n"
                "Внешние файлы обычно перечисляются в заголовке программы. Они существуют до начала работы программы и/или сохраняются после окончания её работы.\n"
                "Внутренние файлы, также как и внешние, описываются в программе как файловые переменные. Их время жизни совпадает со временем работы программы или, в случае динамического сопоставления физических файлов, короче его.\n"
                "Текстовые файлы представляют собой распространённый вид файлов, используемых для ввода-вывода или для хранения данных в виде, непосредственно пригодном для ввода-вывода.\n"
                "Нетекстовые файлы не предназначены для ввода-вывода и хранят данные непосредственно во внутримашинном представлении, которое компактно, "
                "экономит не только место на устройствах внешней памяти, но и время их передачи в оперативную память, причём экономия достигается также и потому, "
                "что не требуется перевода значений в текстовые изображения и обратно."
            )
        },
        {
            "question": "Блочная структура программ. Локальные и глобальные переменные.",
            "answer": (
                "begin // Начало блока языка АЛГОЛ−60\n"
                "<последовательность описаний>\n"
                "<последовательность инструкций>\n"
                "end // Конец блока\n"
                "Во вложенном блоке доступны объекты охватывающего блока, если только они не экранированы омонимичными (одноименными) локальными переменными. "
                "Экранирование означает приоритет локальных объектов над глобальными и является средством разрешения конфликта имен. "
                "В то же время локальные переменные и константы блока недоступны в охватывающих блоках. "
                "В языках с развитой блочной и модульной структурой существуют средства явного экспорта/импорта глобальных и локальных объектов. "
                "Обычно программы, процедуры и функции представляют собой блоки, т.к. имеют описания локальных объектов. "
                "Локальные объекты позволяют не заботиться об уникальности имен при написании больших программ. "
                "Более того, они защищены от несанкционированного использования или от непреднамеренной порчи в большей части программы тем, что просто не видны оттуда. "
                "Локализация области действия переменных и констант позволяет не просто разгрузить глобальный контекст от второстепенных деталей, но и оптимизирует использование памяти."
            )
        },
        {
            "question": "Процедуры и функции. Описание.",
            "answer": (
                "Каждый осмысленный набор процедур и функций фактически представляет собой интерпретативное расширение языка программирования. "
                "В случаях, когда процедуры и функции набора реализуют операции и отношения некоторого типа данных, их можно считать программной реализацией этого типа. "
                "Такие типы данных, не имеющие прямой аппаратной или программной поддержки, принято называть абстрактными. "
                "Процедуры являются одной из первых форм «товарного программирования» и представляют собой простейшую форму программного продукта, "
                "пригодную для повторного использования, продажи или распространения. Они позволяют избежать дублирования кода в тексте программ. "
                "Процедуры, как правило, параметризуются с целью придания им универсальности, причем эта параметризация динамическая, т.е. происходящая в период выполнения программы, "
                "а не на этапе компиляции или препроцессирования, когда осуществляются подстановки или манипуляции с исходным текстом программы.\n"
                "Подпрограммой будем называть именованный фрагмент программы, предназначенный для выполнения специальной инструкцией обращения.\n"
                "Описание и использование: Принадлежностью инструкции вызова подпрограммы является ее имя и набор значений параметров, которые должны быть использованы для вычислений. "
                "Перед использованием подпрограммы необходимо дать ее описание, которое состоит из двух обязательных частей — заголовка и тела.\n"
                "Заголовок определяет количество и порядок следования параметров, которые, как правило, фиксированы.\n"
                "Тело подпрограммы представляет собой блок и содержит описания локальных и глобальных объектов вместе с совокупностью инструкций, описывающих действия алгоритма."
            )
        },
        {
            "question": "Вызов процедур и функций.",
            "answer": (
                "Особенностью описания подпрограмм является наличие в заголовке так называемых формальных параметров, параметризующих тело программы.\n"
                "Подобно всяким локальным объектам, память для формальных параметров выделяется только при входе в блок подпрограммы. "
                "При вызове подпрограммы на место формальных параметров подставляются фактические параметры, так что их значения или ссылки на них замещают формальные параметры в период данного вызова подпрограммы. "
                "При другом вызове на место этих же формальных параметров могут подставляться другие фактические параметры, что и обеспечивает динамизм и универсальность подпрограмм. "
                "В отличие от процедур подпрограммы-функции имеют один явный результат, как правило, скалярный, явно присваиваемый имени функции."
            )
        },
        {
            "question": "Способы передачи параметров.",
            "answer": (
                "Передача по значению: При передаче по значению каждому формальному параметру в соответствии с его типом при вызове подпрограммы выделяется память в области данных программы. "
                "Значение каждого фактического параметра (быть может, выражение) вычисляется в точке вызова подпрограммы и пересылается (ау, матрицы!) в область памяти соответствующего формального параметра, "
                "после чего связь по этому параметру подпрограммы с вызывающей программой прекращается и, в частности, вызванная подпрограмма лишается возможности несанкционированного доступа к оригинальному значению.\n"
                "Передача по результату: В момент вызова подпрограмма, как и в предыдущем случае, получает адрес фактического параметра. "
                "Но в отличие от передачи по значению, по этому адресу при нормальном завершении подпрограммы возвращается вычисленное значение параметра-результата.\n"
                "Передача по ссылке: Этот способ называют также передачей по адресу, передачей по простому имени, подстановкой параметров. "
                "При передаче параметров по ссылке подпрограмме передается адрес объекта в вызывающей программе и все обращения к параметру в подпрограмме происходят по этому адресу, "
                "так что объект в вызывающей программе заменяет соответствующий формальный параметр, то есть не производится передача самого значения и возврат результата. "
                "При этом всякое присваивание значения внутри подпрограммы приводит к одновременному изменению значения объекта в вызывающей программе.\n"
                "Передача по имени: Этот способ откладывает обработку фактических параметров до того момента, когда они действительно потребуются, то есть относится к идеям динамического связывания или динамического знакомства. "
                "Этот метод является самой мощной формой передачи параметров, одновременно наиболее опасной и неэффективной."
            )
        },
        {
            "question": "Понятие рекурсии. Рекурсия и итерация. Примеры.",
            "answer": (
                "Рекурсивным называется объект, частично состоящий или определяемый с помощью самого себя.\n"
                "Пример:\n"
                "#include <stdio.h>\n"
                "long long factorial(int a) {\n"
                "    if (a == 1)\n"
                "        return 1;\n"
                "    return a * (factorial(a - 1));\n"
                "}\n"
                "int main() {\n"
                "    printf(\"%lld\", factorial(5));\n"
                "}\n"
                "Более сложная классификация рекурсий:\n"
                "• Линейная\n"
                "• Повторная (концевая, хвостовая)\n"
                "• Каскадная\n"
                "• Удалённая\n"
                "• Взаимная\n"
                "Рекурсия — это углубляющееся многократное самоприменение.\n"
                "Итерация — повторяющаяся многократная обработка данных, которая не приводит к рекурсивным вызовам программы."
            )
        },
        {
            "question": "Рекурсивный вызов процедур.",
            "answer": (
                "Программы, как и функции, могут быть вызваны рекурсивно.\n"
                "Рекурсивная программа — композиция из множества операторов, не содержащих самой программы.\n"
                "Виды рекурсий:\n"
                "Прямая рекурсия — вызов подпрограммой самой себя по имени, а косвенная — вызов одной через другую программу.\n"
                "Рекурсивные вызовы процедур производятся аналогично вызову одной процедуры из другой. Просто в них все вызываемые процедуры одинаковы.\n"
                "Каждая рекурсивная активация блока порождает новую локальную переменную, а предыдущие одноименные откладываются в стек и экранируются."
            )
        },
        {
            "question": "Критика языков программирования Паскаль и Си.",
            "answer": (
                "Язык Паскаль представляет собой программно-компилируемую реализацию машины фон Неймана и к нему можно отнести всю критику этой алгоритмической модели. "
                "Скалярный оператор присваивания, через бутылочное горлышко которого надо прокачивать сложные математические объекты, заставляет программиста постоянно заботиться о рациональном использовании этой шины (:=) "
                "и отвлекает от решения самой задачи. Справедливости ради отметим, что эта порочная система в прошлом, настоящем и ближайшем будущем остается единственным технически возможным средством автоматизации обработки информации. "
                "Язык Паскаль является строго типизированным языком. Все объекты программ на Паскале должны быть описаны и употребляются в строгом соответствии с описаниями. "
                "Это предполагает строгую дисциплину программирования, неудобную в задачах системного программирования. Однако в своей строгости Паскаль непоследователен. "
                "Например, записи с вариантными частями образуют брешь в системе типизации, не уступающую тому самому метру государственной границы, о котором мечтал герой сатирического романа Остап Бендер. "
                "Тем не менее, особенности Паскаля таковы, что возможна реализация быстрого однопроходного эффективного компилятора. Языковая среда Паскаля также невелика, проста и эффективна. "
                "Паскаль содержит только такие языковые средства, которые эффективно компилируются на аппаратуру. Но это превращается в недостаток, потому что многие нужные любому программисту типы данных "
                "(такие как строки и массивы переменной длины) либо не реализованы вообще, либо их (эффективная) реализация наталкивается на ряд проблем."
            )
        },
        {
            "question": "Критика алгоритмической модели фон Неймана.",
            "answer": (
                "Модель фон Неймана основана на переходах между более сложными (в сравнении с МТ) состояниями. При этом ясность программ и концептуальная польза оказывается выше в сравнении с Тьюрингом.\n"
                "Компьютер фон Неймана состоит из процессора, памяти и соединяющей их шины, передающей между ними одно слово за такт. Это слово либо единица данных, либо команда, либо адрес."
            )
        }
    ]

algo_questions = [
        {"question": "Статические и динамические объекты программ.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Ссылочный тип данных.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Ссылочные типы в современных языках программирования.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Уровни описания структур данных.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Файл. Функциональная спецификация.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Файл. Логическое описание. Физическое представление.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Вектор. Функциональная спецификация.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Вектор. Логическое описание и физическое представление.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Очередь. Функциональная спецификация очереди.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Очередь. Логическое описание и физическое представление (файл).", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Очередь. Логическое описание и физическое представление (массив).", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Очередь. Логическое описание и физическое представление (динамические объекты).", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Стек. Функциональная спецификация стека.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Стек. Аппаратурные аспекты.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Стек. Логическое описание.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Стек. Физическое представление (массив).", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Стек. Физическое представление (динамические объекты).", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Стек. Реализация рекурсии.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Линейный список. Функциональная спецификация.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Линейный список. Логическое описание.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Линейный список. Физическое представление. Итераторы.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Линейный список. Физическое представление (массив).", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Линейный список. Физическое представление (динамические объекты).", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Списки общего вида. Примеры.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Дек. Сравнительное описание. Примеры задач.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Деревья.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Двоичные деревья.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Эквивалентность деревьев общего вида и двоичных деревьев.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Двоичное дерево. Функциональная спецификация.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Двоичное дерево. Логическое описание.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Двоичное дерево: Построение и визуализация.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Двоичное дерево. Физическое представление. Прошивка.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Алгоритмы обхода двоичных деревьев.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Представление и обработка деревьев общего вида.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Представление и обработка графов.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Выражения. Формы записи.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Деревья выражений.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Алгоритм Рутисхаузера.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Алгоритм Бауэра-Замельзона.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Алгоритм Дейкстры.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Деревья поиска. Организация.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Деревья поиска. Вставка и удаление.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Сбалансированные деревья поиска.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Сбалансированные деревья поиска. Включение.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Сбалансированные деревья поиска. Исключение.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Деревья оптимального поиска.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Поиск в последовательностях и таблицах.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Поиск по образцу.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Алгоритм Кнута-Морриса-Пратта.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Алгоритм Бойера-Мура.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Алгоритм Рабина-Карпа.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Таблицы с прямым доступом.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Методы рехеширования.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Задача сортировки. Классификация и свойства сортировок.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Сортировка вставкой.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Сортировка выборкой.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Пузырьковые сортировки.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Сортировка Шелла.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Турнирная сортировка.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Пирамидальная сортировка.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Сортировка Хоора.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Сортировка слиянием.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Сортировка естественным слиянием.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Сортировка строк.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Сортировка подсчётом.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Поразрядная сортировка.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Карманная сортировка.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Сравнительный анализ методов сортировки.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Абстрактные типы данных.", "answer": "✍️ Ответ пока не добавлен"},
        {"question": "Разреженные матрицы.", "answer": "✍️ Ответ пока не добавлен"},
    ]